#!/usr/bin/env python3
"""
Telegram Claude Bot - Polls Telegram for messages and responds via Claude CLI.

Supports two modes:
- Default (lean): Uses MCP Memory only (~2 cents/query)
- Infrastructure (/infra prefix): Uses all MCP servers including Proxmox/UniFi (~7 cents/query)
"""

import os
import sys
import time
import signal
import subprocess
import logging
import threading
import shutil
from typing import Set, Tuple
import requests

from prometheus_client import start_http_server, Counter, Histogram, Gauge

TELEGRAM_BOT_TOKEN = os.environ.get('TELEGRAM_BOT_TOKEN', '{{ telegram_bot_token }}')
ALLOWED_CHAT_IDS: Set[int] = { {{ telegram_allowed_chat_ids | join(', ') }} }
POLL_TIMEOUT = int(os.environ.get('POLL_TIMEOUT', '{{ telegram_poll_timeout }}'))
METRICS_PORT = int(os.environ.get('METRICS_PORT', '{{ telegram_metrics_port }}'))
APPRISE_URL = os.environ.get('APPRISE_URL', '{{ apprise_url }}')
CLAUDE_COMMAND = os.environ.get('CLAUDE_COMMAND', '{{ claude_command }}')

# Config paths for lean vs full mode
HOME_DIR = os.path.expanduser('~')
CLAUDE_CONFIG_LEAN = os.path.join(HOME_DIR, '.claude.json')
CLAUDE_CONFIG_FULL = os.path.join(HOME_DIR, '.claude-full.json')

# Lock for config swapping (prevents race conditions)
config_lock = threading.Lock()

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)]
)
logger = logging.getLogger(__name__)

MESSAGES_RECEIVED = Counter('telegram_messages_received_total', 'Total messages received', ['chat_id', 'authorized'])
MESSAGES_PROCESSED = Counter('telegram_messages_processed_total', 'Total messages processed successfully', ['mode'])
MESSAGES_FAILED = Counter('telegram_messages_failed_total', 'Total messages that failed processing')
RESPONSE_TIME = Histogram('telegram_response_seconds', 'Time to process and respond', ['mode'], buckets=[1, 5, 10, 30, 60, 120, 300])
LAST_POLL_TIME = Gauge('telegram_last_poll_timestamp', 'Timestamp of last successful poll')
BOT_UP = Gauge('telegram_bot_up', 'Bot is running')

running = True
last_update_id = 0


def send_apprise_alert(title: str, message: str, priority: str = 'warning'):
    if not APPRISE_URL:
        return
    try:
        requests.post(APPRISE_URL, json={'title': title, 'body': message, 'type': priority}, timeout=10)
    except Exception as e:
        logger.error(f"Failed to send Apprise alert: {e}")


def get_updates(offset: int = 0) -> list:
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getUpdates"
    params = {'offset': offset, 'timeout': POLL_TIMEOUT, 'allowed_updates': ['message']}
    try:
        response = requests.get(url, params=params, timeout=POLL_TIMEOUT + 10)
        response.raise_for_status()
        data = response.json()
        if data.get('ok'):
            LAST_POLL_TIME.set(time.time())
            return data.get('result', [])
        return []
    except requests.exceptions.Timeout:
        LAST_POLL_TIME.set(time.time())
        return []
    except Exception as e:
        logger.error(f"Error polling Telegram: {e}")
        MESSAGES_FAILED.inc()
        return []


def send_message(chat_id: int, text: str, parse_mode: str = None) -> bool:
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    if len(text) > 4000:
        text = text[:4000] + "\n\n... (truncated)"
    data = {'chat_id': chat_id, 'text': text}
    if parse_mode:
        data['parse_mode'] = parse_mode
    try:
        response = requests.post(url, json=data, timeout=30)
        response.raise_for_status()
        return True
    except Exception as e:
        logger.error(f"Error sending message: {e}")
        # Retry without parse_mode
        try:
            data.pop('parse_mode', None)
            response = requests.post(url, json=data, timeout=30)
            return response.ok
        except:
            return False


def run_claude(prompt: str, use_full: bool = False) -> str:
    """Run Claude CLI with the given prompt via stdin.

    Args:
        prompt: The user's message
        use_full: If True, use full config with all MCP servers (Proxmox, UniFi, Memory)
                  If False, use lean config with just MCP Memory (cheaper)
    """
    try:
        # If using full config, temporarily swap configs
        if use_full and os.path.exists(CLAUDE_CONFIG_FULL):
            with config_lock:
                # Backup lean config
                shutil.copy2(CLAUDE_CONFIG_LEAN, CLAUDE_CONFIG_LEAN + '.bak')
                # Copy full config to active location
                shutil.copy2(CLAUDE_CONFIG_FULL, CLAUDE_CONFIG_LEAN)
                logger.info("Switched to FULL config (Proxmox + UniFi + Memory)")

        try:
            result = subprocess.run(
                [CLAUDE_COMMAND, '--print'],
                input=prompt,
                capture_output=True,
                text=True,
                timeout=300,
                cwd=HOME_DIR,
                env={**os.environ, 'HOME': HOME_DIR}
            )
        finally:
            # Restore lean config if we swapped
            if use_full and os.path.exists(CLAUDE_CONFIG_LEAN + '.bak'):
                with config_lock:
                    shutil.move(CLAUDE_CONFIG_LEAN + '.bak', CLAUDE_CONFIG_LEAN)
                    logger.info("Restored LEAN config")

        logger.info(f"Claude returned code {result.returncode}")
        if result.returncode == 0:
            return result.stdout.strip()
        else:
            error_msg = result.stderr.strip() or result.stdout.strip() or "Unknown error"
            logger.error(f"Claude CLI error (rc={result.returncode}): {error_msg}")
            return f"Error: {error_msg}"
    except subprocess.TimeoutExpired:
        logger.error("Claude CLI timed out")
        # Make sure to restore config on timeout
        if use_full and os.path.exists(CLAUDE_CONFIG_LEAN + '.bak'):
            with config_lock:
                shutil.move(CLAUDE_CONFIG_LEAN + '.bak', CLAUDE_CONFIG_LEAN)
        return "Error: Request timed out (5 minute limit)"
    except Exception as e:
        logger.error(f"Error running Claude: {e}")
        # Make sure to restore config on error
        if use_full and os.path.exists(CLAUDE_CONFIG_LEAN + '.bak'):
            with config_lock:
                shutil.move(CLAUDE_CONFIG_LEAN + '.bak', CLAUDE_CONFIG_LEAN)
        return f"Error: {str(e)}"


def parse_message(text: str) -> Tuple[str, bool]:
    """Parse message for /infra prefix.

    Returns:
        Tuple of (cleaned_message, use_full_config)
    """
    text = text.strip()

    # Check for /infra prefix
    if text.lower().startswith('/infra '):
        return text[7:].strip(), True
    elif text.lower().startswith('/infra'):
        return text[6:].strip() or "What infrastructure information do you need?", True

    # Check for alternative prefixes
    if text.lower().startswith('!full '):
        return text[6:].strip(), True

    return text, False


def process_message(update: dict) -> None:
    message = update.get('message', {})
    chat_id = message.get('chat', {}).get('id')
    text = message.get('text', '')
    user = message.get('from', {})
    username = user.get('username', user.get('first_name', 'Unknown'))

    if not chat_id or not text:
        return

    authorized = chat_id in ALLOWED_CHAT_IDS or not ALLOWED_CHAT_IDS
    MESSAGES_RECEIVED.labels(chat_id=str(chat_id), authorized=str(authorized)).inc()

    if not authorized:
        logger.warning(f"Unauthorized message from chat_id={chat_id}, user={username}")
        send_message(chat_id, "Sorry, you're not authorized to use this bot.")
        return

    # Parse message for /infra prefix
    prompt, use_full = parse_message(text)
    mode = "FULL (infra)" if use_full else "LEAN"
    logger.info(f"Processing [{mode}] message from {username} (chat_id={chat_id}): {prompt[:50]}...")

    # Send typing indicator
    try:
        requests.post(
            f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendChatAction",
            json={'chat_id': chat_id, 'action': 'typing'},
            timeout=5
        )
    except:
        pass

    start_time = time.time()
    response = run_claude(prompt, use_full=use_full)
    elapsed = time.time() - start_time

    logger.info(f"Claude [{mode}] responded in {elapsed:.1f}s with {len(response)} chars")
    mode_label = "full" if use_full else "lean"
    RESPONSE_TIME.labels(mode=mode_label).observe(elapsed)

    if response.startswith("Error:"):
        MESSAGES_FAILED.inc()
        send_apprise_alert("Telegram Bot Error", f"Failed: {response}", "failure")
    else:
        MESSAGES_PROCESSED.labels(mode=mode_label).inc()

    success = send_message(chat_id, response)
    logger.info(f"Message sent: {success}")


def signal_handler(signum, frame):
    global running
    logger.info(f"Received signal {signum}, shutting down...")
    running = False
    BOT_UP.set(0)


def main():
    global running, last_update_id

    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)

    logger.info(f"Starting Prometheus metrics server on port {METRICS_PORT}")
    start_http_server(METRICS_PORT)

    BOT_UP.set(1)

    logger.info("Telegram Claude Bot starting...")
    logger.info(f"Allowed chat IDs: {ALLOWED_CHAT_IDS or 'ALL'}")
    send_apprise_alert("Telegram Bot Started", "Bot is now running.", "info")

    # Clear pending updates
    updates = get_updates(offset=-1)
    if updates:
        last_update_id = updates[-1]['update_id']
        logger.info(f"Cleared {len(updates)} pending updates")

    while running:
        try:
            updates = get_updates(offset=last_update_id + 1)
            for update in updates:
                last_update_id = update['update_id']
                thread = threading.Thread(target=process_message, args=(update,))
                thread.start()
        except Exception as e:
            logger.error(f"Error in main loop: {e}")
            MESSAGES_FAILED.inc()
            time.sleep(5)

    logger.info("Bot stopped")
    send_apprise_alert("Telegram Bot Stopped", "Bot has stopped.", "warning")


if __name__ == '__main__':
    main()
