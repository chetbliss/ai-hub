#!/usr/bin/env python3
"""
Telegram Claude Bot - Polls Telegram for messages and responds via Claude CLI.
"""

import os
import sys
import time
import signal
import subprocess
import logging
import threading
from typing import Set
import requests

from prometheus_client import start_http_server, Counter, Histogram, Gauge

TELEGRAM_BOT_TOKEN = os.environ.get('TELEGRAM_BOT_TOKEN', '{{ telegram_bot_token }}')
ALLOWED_CHAT_IDS: Set[int] = { {{ telegram_allowed_chat_ids | join(', ') }} }
POLL_TIMEOUT = int(os.environ.get('POLL_TIMEOUT', '{{ telegram_poll_timeout }}'))
METRICS_PORT = int(os.environ.get('METRICS_PORT', '{{ telegram_metrics_port }}'))
APPRISE_URL = os.environ.get('APPRISE_URL', '{{ apprise_url }}')
CLAUDE_COMMAND = os.environ.get('CLAUDE_COMMAND', '{{ claude_command }}')

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)]
)
logger = logging.getLogger(__name__)

MESSAGES_RECEIVED = Counter('telegram_messages_received_total', 'Total messages received', ['chat_id', 'authorized'])
MESSAGES_PROCESSED = Counter('telegram_messages_processed_total', 'Total messages processed successfully')
MESSAGES_FAILED = Counter('telegram_messages_failed_total', 'Total messages that failed processing')
RESPONSE_TIME = Histogram('telegram_response_seconds', 'Time to process and respond', buckets=[1, 5, 10, 30, 60, 120, 300])
LAST_POLL_TIME = Gauge('telegram_last_poll_timestamp', 'Timestamp of last successful poll')
BOT_UP = Gauge('telegram_bot_up', 'Bot is running')

running = True
last_update_id = 0


def send_apprise_alert(title: str, message: str, priority: str = 'warning'):
    if not APPRISE_URL:
        return
    try:
        requests.post(APPRISE_URL, json={'title': title, 'body': message, 'type': priority}, timeout=10)
    except Exception as e:
        logger.error(f"Failed to send Apprise alert: {e}")


def get_updates(offset: int = 0) -> list:
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getUpdates"
    params = {'offset': offset, 'timeout': POLL_TIMEOUT, 'allowed_updates': ['message']}
    try:
        response = requests.get(url, params=params, timeout=POLL_TIMEOUT + 10)
        response.raise_for_status()
        data = response.json()
        if data.get('ok'):
            LAST_POLL_TIME.set(time.time())
            return data.get('result', [])
        return []
    except requests.exceptions.Timeout:
        LAST_POLL_TIME.set(time.time())
        return []
    except Exception as e:
        logger.error(f"Error polling Telegram: {e}")
        MESSAGES_FAILED.inc()
        return []


def send_message(chat_id: int, text: str, parse_mode: str = None) -> bool:
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    if len(text) > 4000:
        text = text[:4000] + "\n\n... (truncated)"
    data = {'chat_id': chat_id, 'text': text}
    if parse_mode:
        data['parse_mode'] = parse_mode
    try:
        response = requests.post(url, json=data, timeout=30)
        response.raise_for_status()
        return True
    except Exception as e:
        logger.error(f"Error sending message: {e}")
        # Retry without parse_mode
        try:
            data.pop('parse_mode', None)
            response = requests.post(url, json=data, timeout=30)
            return response.ok
        except:
            return False


def run_claude(prompt: str) -> str:
    """Run Claude CLI with the given prompt via stdin."""
    try:
        result = subprocess.run(
            [CLAUDE_COMMAND, '--print'],
            input=prompt,
            capture_output=True,
            text=True,
            timeout=300,
            cwd=os.path.expanduser('~'),
            env={**os.environ, 'HOME': os.path.expanduser('~')}
        )
        logger.info(f"Claude returned code {result.returncode}")
        if result.returncode == 0:
            return result.stdout.strip()
        else:
            error_msg = result.stderr.strip() or result.stdout.strip() or "Unknown error"
            logger.error(f"Claude CLI error (rc={result.returncode}): {error_msg}")
            return f"Error: {error_msg}"
    except subprocess.TimeoutExpired:
        logger.error("Claude CLI timed out")
        return "Error: Request timed out (5 minute limit)"
    except Exception as e:
        logger.error(f"Error running Claude: {e}")
        return f"Error: {str(e)}"


def process_message(update: dict) -> None:
    message = update.get('message', {})
    chat_id = message.get('chat', {}).get('id')
    text = message.get('text', '')
    user = message.get('from', {})
    username = user.get('username', user.get('first_name', 'Unknown'))

    if not chat_id or not text:
        return

    authorized = chat_id in ALLOWED_CHAT_IDS or not ALLOWED_CHAT_IDS
    MESSAGES_RECEIVED.labels(chat_id=str(chat_id), authorized=str(authorized)).inc()

    if not authorized:
        logger.warning(f"Unauthorized message from chat_id={chat_id}, user={username}")
        send_message(chat_id, "Sorry, you're not authorized to use this bot.")
        return

    logger.info(f"Processing message from {username} (chat_id={chat_id}): {text[:50]}...")

    # Send typing indicator
    try:
        requests.post(
            f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendChatAction",
            json={'chat_id': chat_id, 'action': 'typing'},
            timeout=5
        )
    except:
        pass

    start_time = time.time()
    response = run_claude(text)
    elapsed = time.time() - start_time
    
    logger.info(f"Claude responded in {elapsed:.1f}s with {len(response)} chars")
    RESPONSE_TIME.observe(elapsed)

    if response.startswith("Error:"):
        MESSAGES_FAILED.inc()
        send_apprise_alert("Telegram Bot Error", f"Failed: {response}", "failure")
    else:
        MESSAGES_PROCESSED.inc()

    success = send_message(chat_id, response)
    logger.info(f"Message sent: {success}")


def signal_handler(signum, frame):
    global running
    logger.info(f"Received signal {signum}, shutting down...")
    running = False
    BOT_UP.set(0)


def main():
    global running, last_update_id

    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)

    logger.info(f"Starting Prometheus metrics server on port {METRICS_PORT}")
    start_http_server(METRICS_PORT)

    BOT_UP.set(1)

    logger.info("Telegram Claude Bot starting...")
    logger.info(f"Allowed chat IDs: {ALLOWED_CHAT_IDS or 'ALL'}")
    send_apprise_alert("Telegram Bot Started", "Bot is now running.", "info")

    # Clear pending updates
    updates = get_updates(offset=-1)
    if updates:
        last_update_id = updates[-1]['update_id']
        logger.info(f"Cleared {len(updates)} pending updates")

    while running:
        try:
            updates = get_updates(offset=last_update_id + 1)
            for update in updates:
                last_update_id = update['update_id']
                thread = threading.Thread(target=process_message, args=(update,))
                thread.start()
        except Exception as e:
            logger.error(f"Error in main loop: {e}")
            MESSAGES_FAILED.inc()
            time.sleep(5)

    logger.info("Bot stopped")
    send_apprise_alert("Telegram Bot Stopped", "Bot has stopped.", "warning")


if __name__ == '__main__':
    main()
